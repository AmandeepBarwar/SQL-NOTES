CREATE DATABASE STUDENT;
USE student;

-- Four constraints are used Primary key, unique key, foreign key, default
-- default keep the same value throught the row 
-- CHECK 
CREATE TABLE EMPLOYEE (ID INT PRIMARY KEY, NAME VARCHAR(50), 
SALARY INT, CONSTRAINT SALARY CHECK (SALARY>=25000)  );

-- CHECK IS USED TO CHECK ANY CONDITION LIKE (AGE INT CHECK (AGE>=18))

INSERT INTO EMPLOYEE 
(ID, NAME, SALARY)
VALUES
(1, 'ADAM', 25000),
(2, 'BOB', 30000),
(3, 'CASEY', 35000);

-- THIS LINE WILL MAKE ERROR AS IT HAVE VOILATED CHECK CONTRAINT OF SALARY>=25000

INSERT INTO EMPLOYEE VALUES (4, 'SHADAB', 20000);

/* OPERATORS AND(TRUE WHEN BOTH ARE TRUE) and OR(FALSE WHEN SINGLE IS FALSE)*/

/* BETWEEN-AND(SETS RANGE), IN (USED FOR DEFINING ELIGIBILITY 
(WHERE CITY IN ('MUMBAI')) ) , NOT(USED TO DISLECT THOSE ARE MENTIONED IN THIS
(WHERE CITY NOT IN ('DELHI'))) */

/* LIMIT USED TO SET UPPER LIMIT TO NUMBER OF ROWS (WHERE SALARY >=25000 LIMIT 2) 
THIS WILL PRINT TOP 2 ROWS OF TABLE*/

/* ORDER BY DEFINES THE SORTING OF TABLE EITHER ASCENDING (ASC) 
OR DESCENDING (DESC)*/

SELECT * FROM EMPLOYEE WHERE SALARY >20000 LIMIT 4;
SELECT SALARY FROM EMPLOYEE ORDER BY SALARY DESC;
/* AGGREGATE FUNCTION
COUNT(), MIN(), MAX(), SUM(), AVG()*/
-- THESE FUNCTION ARE USED FOR GRABBING INFORMATION FROM GIVEN TABLE
SELECT SUM(SALARY) FROM EMPLOYEE;

ALTER TABLE EMPLOYEE ADD COLUMN CITY VARCHAR(50);
UPDATE EMPLOYEE SET CITY = 'DELHI' WHERE ID = 1;
UPDATE EMPLOYEE SET CITY = 'MUMBAI' WHERE ID = 2;
UPDATE EMPLOYEE SET CITY = 'DELHI' WHERE ID = 3;
SELECT * FROM EMPLOYEE;
SELECT CITY, AVG(SALARY) FROM EMPLOYEE GROUP BY CITY ORDER BY AVG(SALARY) ASC;

CREATE TABLE PAYMENT(
    CUSTOMER_ID INT PRIMARY KEY, 
    CUSTOMER VARCHAR(50), 
    MODE VARCHAR(20), 
    CITY VARCHAR(20)
);

INSERT INTO PAYMENT (CUSTOMER_ID, CUSTOMER, MODE, CITY) 
VALUES
(1, 'OLIVIA BARRETT', 'NETBANKING', 'PORTLAND'),
(2, 'ETHAN SINCLAIR', 'CREDIT CARD', 'MIAMI'),
(3, 'MAYA HAMENDEZ', 'CREDIT CARD', 'SEATTLE'),
(4, 'LIAM DONOVAN', 'NETBANKING', 'DENVER'),
(5, 'SOPHIA', 'CREDIT CARD', 'NEW ORLEANS'),
(6, 'CALEB FOSTER', 'DEBIT CARD', 'MINNEAPOLIS'),
(7, 'AVA PATEL', 'DEBIT CARD', 'PHOENIX'),
(8, 'LUCAS CARTER', 'NETBANKING', 'BOSTON'),
(9, 'ISABELLA MARTINEZ', 'NETBANKING', 'NASHVILLE'),
(10, 'JACKSON BROOKS', 'CREDIT CARD', 'BOSTON');
SELECT MODE, COUNT(MODE) FROM PAYMENT GROUP BY MODE;
SELECT * FROM PAYMENT;

/* having clause is used similar to where clause but difference is that 
where works on rows and having can work on groups */

SELECT MODE, COUNT(MODE)
FROM PAYMENT
GROUP BY MODE
HAVING COUNT(MODE) > 2;

/* GENERAL ORDER FOR SELECT STATEMENT
SELECT COLUMN
FROM TABLE_NAME
WHERE CONDITION
GROUP BY COLUMN(s)
HAVING CONDITION
ORDER BY COLUMN DESC;*/

SELECT SALARY
FROM EMPLOYEE
WHERE SALARY > 24000
GROUP BY SALARY
HAVING MAX(SALARY) > 24000
ORDER BY SALARY ASC;

-- UPDATE - SET - WHERE 
/*UPDATE TBALE_NAME 
SET COLUMN = NEW_VALUE 
WHERE LOCATION*/

UPDATE PAYMENT  -- UPDATE TABLE_NAME
SET MODE = 'UPI'  -- SET COL. = NEW VALUE
WHERE MODE = 'NETBANKING';  -- WHERE COL. = OLD VALUE 

SELECT * FROM PAYMENT;

-- DELETE FROM - WHERE 

DELETE FROM PAYMENT 
WHERE CUSTOMER_ID = 10;

INSERT INTO PAYMENT VALUES(10, 'JACKSON BROOKS', 'CREDIT CARD', 'BOSTON');

CREATE TABLE 
DEPARTMENT (ID INT PRIMARY KEY, SUBJECT VARCHAR(10) UNIQUE KEY);

INSERT INTO 
DEPARTMENT (ID, SUBJECT)
VALUES
(101, 'SCIENCE'),
(102, 'ENGLISH'),
(103, 'MATHS');

INSERT INTO DEPARTMENT VALUES
(104, 'CSE');

/* ON DELETE CASCADE
USED WITH FOREIGN KEY TO MAKE SURE THAT DELETION DONE AT BOTH TABLES*/

/* ON UPDATE CASCADE
USED WITH FOREIGN KEY TO MAKE SURE THAT ANY UPDATE MADE IS DONE AT BOT THE TABLES*/


CREATE TABLE 
TEACHER (
ID INT PRIMARY KEY, 
NAME VARCHAR(10), 
T_ID  INT, 
FOREIGN KEY (T_ID) REFERENCES DEPARTMENT(ID)
ON DELETE CASCADE
ON UPDATE CASCADE
);

INSERT INTO 
TEACHER(ID, FULL_NAME, T_ID)
VALUES
(1, 'ADAM', 102),
(2, 'BOB', 103),
(3, 'CASEY', 101),
(4, 'AMAN', 103);

ALTER TABLE TEACHER
CHANGE COLUMN NAME FULL_NAME VARCHAR(20);

DELETE FROM TEACHER
WHERE T_ID > 102;

ALTER TABLE director 
DROP COLUMN dname;

select * from director;

SELECT * FROM TEACHER;

SELECT * FROM DEPARTMENT;

UPDATE DEPARTMENT 
SET ID = 101
WHERE ID = 111;

/* ALTER
USED TO CHANGE THE SCHEMA
ALTER TABLE TABLE_NAME
(ADD, DROP, RENAME) COLUMN
(MODIFY) COULUMN_NAME NEW_DATATYPE NEW_CONSTRAINT
(CHANGE COLUMN(RENAME)) OLD_NAME NEW_NAME NEW_DATATYPE NEW_CONSTRAINT
*/ 

ALTER TABLE DEPARTMENT 
MODIFY SUBJECT VARCHAR(20);

ALTER TABLE PROFESSOR
RENAME TEACHER ;

ALTER TABLE TEACHER 
ADD COLUMN T_AGE INT DEFAULT 30;

-- TRUNCATE TABLE TABLE_NAME DELETES THE DATA OF TABLE
-- DROP TABLE TABLE_NAME DELETES THE WHOLE EXISTANCE OF TABLE

CREATE TABLE IF NOT EXISTS
UK (ID INT PRIMARY KEY, SUBJECT VARCHAR(10) UNIQUE KEY);

INSERT INTO 
UK (ID, SUBJECT)
VALUES
(101, 'SCIENCE'),
(102, 'ENGLISH'),
(103, 'MATHS');

TRUNCATE TABLE UK;

SELECT * FROM UK;
DROP TABLE UK;

/* JOINS
IT IS USED TO COMBINE TWO OR MORE TABLES BASED UPON THEIR COMMOM RELATED COLUMN
BETWEEN THEM
IT IS OF 4 TYPES
1. INNER JOIN 
	SELECT COLUMN
    FROM TABLE_1 
    INNER JOIN TABLE_2
    ON TABLE_1.COL_NAME = TABLE_2.COL_NAME

2. LEFT JOIN
	SELECT COLUMN
    FROM TABLE_1
    LEFT JOIN TABLE_2
    ON TABLE_1.COL_NAME = TABLE_2.COL_NAME
    
3. RIGHT JOIN
	SELECT COLUMN
    FROM TABLE_1
    RIGHT JOIN TABLE_2
    ON TABLE_1.COL_NAME = TABLE_2.COL_NAME

4. FULL JOIN
	SELECT COLUMN
    FROM TABLE_1
    LEFT JOIN TABLE_2
    ON TABLE_1.COL_NAME = TABLE_2.COL_NAME
    UNION
	SELECT COLUMN
    FROM TABLE_1
    RIGHT JOIN TABLE_2
    ON TABLE_1.COL_NAME = TABLE_2.COL_NAME    


*/

SELECT *
FROM DEPARTMENT AS D
INNER JOIN TEACHER AS T
ON D.ID = T.T_ID;

SELECT *
FROM DEPARTMENT AS D
LEFT JOIN TEACHER AS T
ON D.ID = T.T_ID;
/* CATCH :- HERE ROW OF CSE SUBJECT IS NULL AS NO DATA 
IN TEACHER TABLE BUT INNER JOIN IS APPLIED*/

SELECT *
FROM DEPARTMENT AS D
RIGHT JOIN TEACHER AS T
ON D.ID = T.T_ID;

/* UNION 
IT IS USED TO COMBINE TWO TABLES 
*/

SELECT *
FROM DEPARTMENT AS D
LEFT JOIN TEACHER AS T
ON D.ID = T.T_ID
UNION
SELECT *
FROM DEPARTMENT AS D
RIGHT JOIN TEACHER AS T
ON D.ID = T.T_ID;

/*SELECT * 
FROM DEPARTMENT AS D
FULL OUTER JOIN TEACHER AS T
ON D.ID = T.T_ID; 
MySQL does not support the 'FULL OUTER JOIN' syntax directly.
*/

/*
1. LEFT EXCLUSIVE JOIN
	SELECT *
	FROM DEPARTMENT AS D
	LEFT JOIN TEACHER AS T
	ON D.ID = T.T_ID
	WHERE T_ID IS NULL;	

2. RIGHT EXCLUSIVE JOIN
	SELECT *
	FROM DEPARTMENT AS D
	RIGHT JOIN TEACHER AS T
	ON D.ID = T.T_ID
	WHERE D.ID IS NULL;	

*/

SELECT *
FROM DEPARTMENT AS D
RIGHT JOIN TEACHER AS T
ON D.ID = T.T_ID
WHERE D.ID IS NULL;	

/* SELF JOIN
THIS JOIN IS SHRADDHA MA'AM's JOIN USED TO JOIN TABLE_1 WITH TABLE 1
	SELECT *
	FROM DEPARTMENT AS D
	JOIN TEACHER AS T
	ON T.ID = T.T_ID
*/

/* SQL SUB QUERIES
A Subquery or Inner query or a Nested query is a query within another 
SQL query. It involves 2 select statements.
	SELECT column(s)
	FROM table_name
	WHERE col_name operator ( subquery );
*/

SELECT NAME, SALARY
FROM EMPLOYEE
WHERE SALARY > (SELECT AVG(SALARY) FROM EMPLOYEE);

CREATE TABLE STUDENTS(
	ID INT PRIMARY KEY,
	NAME VARCHAR(50),
	MARKS INT,
	CITY VARCHAR(10)
);

INSERT INTO 
STUDENTS (ID, NAME, MARKS, CITY)
VALUES
(101, 'ANIL', 78, 'PUNE'),
(102, 'BHUMIKA', 93, 'MUMBAI'),
(103, 'CHETAN', 85, 'MUMBAI'),
(104, 'DHRUV', 96, 'DELHI'),
(105, 'EMANUEL', 92, 'DELHI'),
(106, 'FARAH' ,82, 'DELHI');

-- USE OF SQL SUB QUERY WITH 'WHERE'
SELECT NAME, MARKS
FROM STUDENTS
WHERE MARKS > (SELECT AVG(MARKS) FROM STUDENTS);

SELECT NAME, ID
FROM STUDENTS
WHERE ID IN (SELECT ID FROM STUDENTS WHERE ID % 2 = 0);
 
-- USE OF SQL SUB QUERY WITH 'FROM'  
SELECT MAX(MARKS)
FROM(
	SELECT NAME, MARKS, CITY
	FROM STUDENTS
	WHERE CITY = 'DELHI'
) AS TEMP ;

/* AS TEMP IS ALIAS OF TABLE CONTAINING DETAILS OF STUDENTS OF DELHI
NECESSORY TO APPLY SO THAT NO ERROR OCCUR IN CODE */

-- WAY TO FIND MAX MARKS OF DELHI STUDENTS WITH USING 'WHERE'
SELECT NAME, MARKS 
FROM STUDENTS
WHERE MARKS = (
SELECT MAX(MARKS)
FROM STUDENTS
WHERE CITY = 'DELHI'
);

-- WAY TO FIND MAX MARKS OF DELHI STUDENTS WITH USING 'SELECT'

SELECT NAME, (SELECT MAX(MARKS) FROM STUDENTS)
FROM STUDENTS;

-- CATCHE IN THIS IT WILL PRINT ALL STUDENTS MARKS TO MAXIMUM MARKS 

/* MY SQL VIEWS
A view is a virtual table based on the result-set of an SQL statement.
	CREATE VIEW VIEW1 AS
    SELECT COLUMN(s) FROM TABLE_NAME;
    
    SELECT * FROM VIEW1;
    
IT IS JUST VIRTUAL ANOTHER TABLE IS NOT CREATED IN DATABASE    
*/

CREATE VIEW PARENTS_VIEW  AS
SELECT ID, NAME, MARKS FROM STUDENTS;

SELECT * FROM PARENTS_VIEW;

-- SQL :)
